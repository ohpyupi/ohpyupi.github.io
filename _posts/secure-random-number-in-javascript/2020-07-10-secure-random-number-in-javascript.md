---
layout: post
title: Secure Random Number Generation in Javascript
tags: [prng, cryptography, javascript]
date: 2021-07-10
categories: engineering
---
# tl;dr
1. Always use cryptographically-secure PRNG (CSPRNG) for cryptographic use
2. Make sure your CSPRNG does not have modular bias

# Introduction
Recently, there was a weakness disclosed in Kaspersky Password Manager (KPM). Visit [this link][KPM Article] for the full article.
The weakness is that KPM's password generation algorithm used (1) non-CSPRNG and (2) a single source of entropy to generate passwords.

The danger of PRNG is that hackers can read a generated random number at some point, and trace all random numbers
that had been generated previously or to be generated in the future. Also, normally to generate pseudo number in PRNG, entropy is provided
to the PRNG functions. The entropy is a degree of uncertainty, and this is also known as "seed" in cryptographic world.

The impact is significant if the weakness is exploited. Within a year, there are 315619200 seconds.
Because KPM used the current time as a seed to the algorithm, the algorithm can generate only 315619200 passwords for a given character set.
This make the all passwords generated by KPM to be breakable.

Currently, KPM made a fix, and they notified their customers to re-generate passwords.

# What can go wrong?
We took the recent vulnerability report found in KPM. Then, let's take a look at how things can go wrong in our lives.
I will take Javascript as the example programming language here. Normally, when things need to be random, we rely on the function `Math.random`.

This function is totally suitable in typical use cases. However, if by any chance the random number you generated through `Math.random`
will be used for any cryptographical use cases, such as encryption/decryption and providing confidentiality for certain dataset, you will surely mess up yourself by doing so.

There comes the CSPRNG to save your life. CSPRNG is essentially a type of PRNG. However, its pseudo-randomness is secure for the cryptographical usage.
I won't go over the details of CSPRNG, but will share an example of CSPRNG in Browsers. Modern browsers provide [WebCrypto API][WebCrypto API], and it is an API that contains
functions for encryption, decryption, key generation, etc. And the API has a function `crypto.getRandomValues` that can be used to get random numbers.

Let's take some examples to get things easier. Here are an example of using `Math.random`, which can be inappropriate for cryptographic use case.
```js
/**
 * Generate a randum number [0, upperBound) - exclusive upperBound
 * @param {number} upperBound
 * @return {number}
 */
const getRandomNumber = (upperBound) => 
    Math.floor(Math.random() * upperBound);
```

If someone asks you to review a PR that contains the function above, and the function is being used for cryptographic use, you should definitely thumb down the PR.
Here is what can be suggested instead.

```js
/**
 * Generate a randum number [0, upperBound) - exclusive upperBound
 * @param {number} upperBound
 * @return {number}
 */
const getRandomNumber = (upperBound) => {
    const byteArray = new Uint8Array(1);
    window.crypto.getRandomValues(byteArray)
    const randomByte = byteArray[0];  
    const randomNumber = randomByte % upperBound;
    return randomNumber;
};
```

Now in the suggestion above, it uses CSPRNG function, `crypto.getRandomValues`. So it will be much more secure than the implementation with `Math.random`.
Then, are we good to go and thumb up the PR? Unfortunately, this suggested code can also make your life hard when it goes to the production.

We need to ask ourselves again if your code returns the truly random numbers. Of course, we used CSPRNG `crypto.getRandomValues` in order to generate random value.
However, we added additional logic around it. Let's take a close look at what can go wrong again in this code.

```js
const byteArray = new Uint8Array(1);
```
This line of code will return an array of 8-bit integers. In a plain English, it is an array of integers that can range from 0 to 255.
See [here][Uint8Array] to know more details about `Uint8Array`.
Also, the instance of it will always initialize with 0's. And since we provided the length argument to be 1. It will eventually return `[0]`.

```js
window.crypto.getRandomValues(byteArray)
```
And on the second line, we pass the `byteArray` to the `crypto.getRandomValues` function. Then the `byteAray`'s values will be randomized.

```js
const randomByte = byteArray[0];  
```
After the `byteArray`'s values are randomized, we access the first element to get the random number. Here, the random number
is from 0 to 255. We are all good for now. Because the random number is generated by the CSPRNG, and it is proven to be secure.

```js
const randomNumber = randomByte % upperBound;
```
Normally, we want to get a random number from certain range, for example 0 to 9, 0 to 99, etc. In order to do so, we can use modular operation
to resize the random number range into the range we want to achieve. Finally, this random number will be returned and used.

Now, the problem arises here using the modular operation without careful attention.
Let's take a simple example to see how things can go wrong.
Let say, you have a CSPRNG `getRandom16` that generates 4-bits integers, [0, 16).
And using the modulo operation you want to resize that random number to [0, 9).
We can actually see how the result will look like.

```js
getRandom16()    // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
getRandom16 % 10 // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,  0,  1,  2,  3,  4,  5]

// Probability of 0, 1, 2, 3, 4, 5 = 1 / 8 (12.5%)
// Probability of 6, 7, 8, 9       = 1 / 16 (6.25%)
```

Now you can clearly see that the probability of having smaller numbers (0, 1, 2, 3, 4, 5) are twice bigger than other bigger numbers.
This is called modular bias and without paying attention to it, developers can still implement dangerous random number generation function
even using CSPRNG.

## How to avoid modular bias? Rejection Sampling!

Now we are clear that even with CSPRNG, things can go wrong because of modular bias. Then, let's see how we can avoid it.
A most common way is rejection sampling. Basically, we will reject numbers in the false range. For example, in the example above,
the numbers in the right range is [0, 9]. So we will just simply reject the number in [10, 15]. Let's see the improved code.

```js
const getRandomNumber = (upperBound) => {
    const byteArray = new Uint8Array(1);
    let randomNumber;
    do {
        window.crypto.getRandomValues(byteArray)
        randomNumber = byteArray[0]
    } while (randomNumber >= upperBound)
    return randomNumber;
};   
```

This will surely remove the modular bias. But, as you also sense it, this is not an efficient approach.
For example, we still use `getRandom16`, but we want the random number in range of [0, 2]. It will reject too many numbers.
When the random number size is bigger, it can result in performance issue. So we can go more to optimize the code.

In order to do so, we can use a mathematical condition that returns the uniform distribution out of modulo operation.

> Given the random number max value RAND_MAX and the uppper bound n,
> the uniform distribution is achieved when RAND_MAX % n = n- 1.

Utilizing the condition above, the `getRandomNumber` can be further optimized as following.
```js
const getRandomNumber = (upperBound) => {
    const RAND_MAX = 255;
    const byteArray = new Uint8Array(1);
    let randomNumber;
    do {
        window.crypto.getRandomValues(byteArray)
        randomNumber = byteArray[0]
    } while (randomNumber > RAND_MAX - (((RAND_MAX % upperBound) + 1) % upperBound))
    return randomNumber % upperBound;
};   
```
For the detailed analysis on the optimization, you can read [this][Stack Overflow Modular Bias] Stack Overflow post and comments.

# Best Practice
Now, we know that in order to achieve random number generation in cryptographic use, we need to (1) use CSPRNG and (2) avoid modular bias.
And also, we went through how to implement a random number generation function using `crypto.getRandomValues` and modulo operation.

But, do I recommend using the `getRandomNumber` function above? Absolutely no. 
In general, implementing cryptographical functions on your own is not a best practice.
Hence, even if someone raises a PR having a random number generation with perfect care of CSPRNG and modular bias.
I will thumb down the PR, and politely ask him to find and use a trusted open source library that already implemented such functionalities.

I strongly recommend using [Libsodium][Libsodium] library if you need a random number function for cryptographic use.
It has a method `randombytes_uniform` that guarantees the use of CSPRNG and no modular bias.
Also, the library is cross-platform library. Thus, if your applications requires some cross-platform cryptographic communication,
the library can be used between different platforms.

So your `getRandomNumber` function will be as following.
```js
/**
 * Generate a randum number [0, upperBound) - exclusive upperBound
 * @param {number} upperBound
 * @return {number}
 */
const getRandomNumber = (upperBound) => sodium.randombytes_uniform(upperBound);   
```

Thanks for reading my post. I wrote this article since I personally struggled in understanding what can really go wrong when implementing PRNG.
Hope this post helped you as well!

[KPM Article]: https://donjon.ledger.com/kaspersky-password-manager/
[WebCrypto API]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API
[Uint8Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
[Stack Overflow Modular Bias]: https://stackoverflow.com/questions/10984974/why-do-people-say-there-is-modulo-bias-when-using-a-random-number-generator
[Libsodium]: https://github.com/jedisct1/libsodium.js